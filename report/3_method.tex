\section{Method}
The following section describes how the different components work as well as a more detailed view of how the MESI and Dragon protocols work.

\subsection{Components}
Figure \ref{fig:overview} shows an overview of how the different components in the simulation are
structured. We can see that a loader component unpacks a zip archive and passes each file as a
record stream to a corresponding core in the system. Each core has one cache each and is connnected
to the bus.

\begin{figure}[ht]
    \centering
    \incfig{overview}
    \caption{Overview}
    \label{fig:overview}
\end{figure}



\subsubsection{Record}

A record consists of a label and a value.  During the initialization of the simulation, a loader
unpacks the passed zip archive and converts each file contained in the zip archive to a record
stream.  Given the following line in one such unpacked file
\begin{lstlisting}
0 0x817ae8
\end{lstlisting}
a record will be created in the following form
\begin{lstlisting}
Record {
    label: Label::Load,
    value: 0x817ae8
}
\end{lstlisting}


\subsubsection{System}
The system keeps the state of all the cores and make sure that each core is updated.
The system will create as many cores as needed to satisfy each file unpacked from the zip archive.
The update step for each core consists of three stages: \texttt{step}, \texttt{snoop} and \texttt{after\_snoop}.
The \texttt{step} stage parses the new instruction into a record and updates the state given the record.
The \texttt{snoop} stage will snoop the bus.
If the bus currently have an active task and the task's issuer is not the core that is snooping the core may update its state given the active task and current state for that cache line.
The \texttt{after\_snoop} stage is a cleanup stage done after the snooping stage.
It consists of changing the state of a cache line depending on the outcome of the snoop stage, that is, if it turns out that the cache line should be shared.
The update is structured this way to avoid race conditions between each intermediate state.


\subsubsection{Core}
The core keeps the state of the cache and all the records.

\subsubsection{Cache}
The cache keeps the state of each cache line, the corresponding LRU value for each cache line, which
protocol is in use, the scheduled instructions as well as the address layout of the cache.  When the
cache is initialized in each core the address layout is calculated and consists of the offset
length, the index length, the tag length, the set size and the block size.  The cache lines and LRU
are both represented as a two dimensional vector containing an unsigned integer, where the rows
represent the sets and the columns represent the blocks.  Note that there is no need to index the
words directly as we load the whole block each time we access a word within the block.  The
scheduled instructions are stored as a deque containing a tuple, the address and the action.  There
are two valid actions a scheduled instruction can have, read and write.  Read operations are
inserted at the front of the deque, while the write operations are inserted at the back of the
deque.  Since the deque is processed from front to back, higher priority will be given to the read
operations rather than the write operations.

The cache is updated at every step the core is updated.  During an update the cache first checks if
there is an active task on the bus that does not belong to the core that is updating.  If that is
not the case, the cache will return immediately, stalling the cache as the cache has to wait for its
last task to finish.  Otherwise the cache will pop the front of the deque and try to do either an
internal load or internal store depending on the action of the popped instruction.  An internal load
will search for the given address to see if it is already present in the cache, a hit, and perform
the neccesary steps to update the state for the cache line depending on which protocol which is in
use.  If there is not cache hit, the cache will check if a writeback is needed given the current
value on the cache line.  An internal store will also search for the given address to see if it
present in the cache, but will in the case of a cache miss push a read action to the deque to fetch
the current address before writing to it --- write-allocate policy.  Both the internal load and
internal store will put the needed action on the bus if the bus is not occupied and it is required
by the state transition.


\subsubsection{Bus}

The bus keeps track of the current task on the bus. There can only be one such task at one time. A
task has the following form:

\begin{lstlisting}
Task {
    issuer_id: usize,
    remaining_cycles: usize,
    action: BusAction,
}
\end{lstlisting}

Thus, the task contains the id of the core that issued the task, the remaining clock cycles until
the task is finished and the type of bus action.  There are a couple of bus actions which are shared
between both protocols.  That is, a bus action like \texttt{BusUpdShared} is only valid for the
Dragon protocol, so when the MESI protocol is used, this action is ignored.  The bus actions are
represented in the following form:

\begin{lstlisting}
BusAction {
    BusRdMem(address, n_bytes),
    BusRdShared(address, n_bytes),
    BusRdXMem(address, n_bytes),
    BusRdXShared(address, n_bytes),
    BusUpdMem(address, n_bytes),
    BusUpdShared(address, n_bytes),
    Flush(address, n_bytes),
}
\end{lstlisting}

Each bus action state contains an address and the number of bytes used for the bus exchange.  Each
update cycle the bus proceeds to advance the bus transaction if there is one.

\subsubsection{Protocol}
\label{sec:sub_protocol}
The protocol is implemented as a trait, where a trait defines shared behaviour.  This is very
similar to how interfaces work in other languages than Rust, with some minor differences.  For
example, traits cannot have fields.  The shared behaviour for protocol trait is defined like:

\begin{lstlisting}
read()
write()
snoop()
after_snoop()
writeback_required()
invalidate()
is_shared()
\end{lstlisting}
These operations are required for the implementation of the MESI protocol and the Dragon protocol.
As briefly described earlier in the cache section, the cache keeps track of the current protocol in
use.  When the cache is doing operations on specific cache lines, it invokes the proper method for
the underlying protocol as defined in the trait.  Thus, the protocol is stored like
\begin{lstlisting}
protocol: Box<dyn Protocol>
\end{lstlisting}
and operations are for example invoked like
\begin{lstlisting}
protocol.snoop(...)
\end{lstlisting}

This is really useful as the cache does not need to know which protocol is used, but relying on the fact that the underlying protocol has some defined behaviour for the invoked operation.
In every update cycle, as described earlier, there are three phases

\begin{enumerate}
    \item \textbf{Step}. The step phase correspond to either a \texttt{read()} or \texttt{write()}.
    \item \textbf{Snoop}. The snoop phase correspond to \texttt{snoop()}.
    \item \textbf{After snoop}. The after snoop phase correspond to \texttt{after\_snoop()}.
\end{enumerate}

\subsection{Protocol}
Like described in section \ref{sec:sub_protocol}, each protocol needs to implement a set of method
to satisfy the trait.  The following two sub sections will go in depth how the MESI protocol and
Dragon protocol implements these, as well as show the state diagrams that come up.

\subsubsection{MESI}

A transition diagram for our implementation of the processor initiated transitions for the MESI protocol can be found in Figure \ref{fig:mesi}.
However, this is a bit different from the transition diagram found on Wikipedia \cite{mesi_wiki}.
The transition diagram found on Wikipedia has a transition from the invalid state (I) to the shared state (S), which cannot be found Figure \ref{fig:mesi}.
This among all other transistions will be described in the following section.

TODO: describe cache hit for I. 


\begin{figure}[H]
    \centering
    \incfig{mesi}
    \caption{Mesi. The step phase of the update cycle.}
    \label{fig:mesi}
\end{figure}

$I \to S$. The transition from invalid (I) to shared (S) is instead modeled using the step phase (see Figure \ref{fig:mesi}) and the after snoop phase (see Figure \ref{fig:mesi_after_snoop}).
When a cache miss occurs, the cache line is moved from invalid (I) to exclusive (E) as seen in Figure \ref{fig:mesi}.
This will issue a bus transaction as a miss occured.
Another core that is currently holding the same cache line will snoop the bus transaction and change the transaction to signal that it is currently holding the same cache line.
The core that issued the bus transaction will in the after snoop phase acknowledge the shared signal and change its state to S, see the transistion from E to S in Figure \ref{fig:mesi_after_snoop}.

$I \to E$.
When a cache miss occurs, the core will transistion to E.
It will issue a bus transaction, but since no other core is holding the same cache line, the transaction will not be changed in the snoop phase, eliminating the chance of transitioning to S in the after snoop phase.

$I \to M$.
When a cache write miss occurs the core must first fetch the data due to write-allocate.
A write-allocate is simulated by stalling for the standard penalty amount of a read miss, while transitioning the cache line to state M as seen in Figure \ref{fig:mesi}.
A \texttt{BusRdXMem} bus transaction will be issued.
Other cores that are snooping will notice this.
They will invalidate their cache lines and transition to I.

\begin{figure}[H]
    \centering
    \incfig{mesi_snoop}
    \caption{Mesi. The snoop phase of the update cycle.}
    \label{fig:mesi_snoop}
\end{figure}

$S \to S$.
When a read hit occurs, no state transition will occur and no bus transation will be issued.
Thus, the state will stay in S.

$S \to M$.
When a cache hit occurs while a core is writing to a cache line that is in S, a transition to M will occur and a \texttt{BusRdXMem} bus transaction will be issued.
Other cores that are snooping will notice this.
They will invalidate their cache lines and transition to I.

$E \to E$.
When a cache hit occurs while a core is reading to a cache line that is in E, the cache line will remain in E and no bus transaction will be issued.

$E \to M$.
When a cache hit occurs while a core is writing to a cache line that is in E, a transition to M will occur but no bus transaction since the core can be sure that has the only copy of the cache line.

$M \to M$.
When a cache hit occurs while a core is writing or reading to a cache line that is in M, the cache line will remain in M and no bus transaction will be issued since it can be sure that no other core has a copy of the cache line.


\begin{figure}[H]
    \centering
    \incfig{mesi_after_snoop}
    \caption{Mesi. The after snoop phase of the update cycle.}
    \label{fig:mesi_after_snoop}
\end{figure}

From a bus transaction, a cache line can either go to S or I by looking at the Figure \ref{fig:mesi_snoop}.
When a \texttt{BusRdMem} occurs the cache line will go to state S, as it knows that some other core has currently accessed the same cache line.
This will as mentioned happend in the snoop phase.
The core that is changing the cache line to S will also change the type of the bus transaction to allow the scenario described for transition ($I \to S$).
Moreover, a core that is reading a cache line that another core has in its cache should be able to transition to S in the after snoop phase, while the other core should be able to switch to S in the snoop phase.
When a \texttt{BusRdXMem} occurs the cache line will go to state I, as it knows that some other core has currently written to the same cache line.
A cache line can also go to state I if it is evicted.
When a cache line in M is evicted or invalidated, it must be flushed.
A flush will result in stalling all cores until the operation is complete.

\subsubsection{Dragon}

\begin{figure}[H]
    \centering
    \incfig{dragon}
    \caption{Dragon. The step phase of the update cycle.}
    \label{fig:dragon}
\end{figure}


\begin{figure}[H]
    \centering
    \incfig{dragon_snoop}
    \caption{Dragon. The snoop phase of the update cycle.}
    \label{fig:dragon_snoop}
\end{figure}

\begin{figure}[H]
    \centering
    \incfig{dragon_after_snoop}
    \caption{Dragon. The after snoop phase of the update cycle.}
    \label{fig:dragon_after_snoop}
\end{figure}


\subsection{Testing}
